---
title: "[TID] OOP"
date: 2020-02-06 13:43:00 -0400
categories: TID OOP class prototype 
---
## OOP (객체 지향 프로그래밍) ?

객체로 이루어진 세상을 한번 상상해 보자.

마트의 상품을 진열하는 직원이 되었다고 상상을 해보자 상품을 진열하고, 가격표를 붙히기 위해 상품 이름, 가격이 적혀있는 표를 받았다.


상품이름 | 설명
--- | --- |
|앞다리 100g당 가격 | 1000  |
|앞다리1 무게 | 850 |
|앞다리1 할인률  |  30 |
|앞다리2 무게 | 600 |
|앞다리2 할인률 | 10  |
| ... | ... |

```js
var 앞다리1무게 = 850
var 앞다리1할인률 = 30
var 앞다리2무게 = 600
var 앞다리2할인률 = 10

function getPrice(price, weight, rate) {
  return price * weight * (100 - rate)/100;
}
var 앞다리1가격 = getPrice(앞다리 가격, 앞다리1무게, 앞다리1할인률);
// ...
// 각각의 변수이름을 지정해줘야하는 불편함이 있다.
```
## EnCapsulation
```js
var 앞다리1 = {
  가격 : 1000,
  무게 : 850,
  할인률 : 30,
  getPrice : function() {
    return this.가격 * this.무게 * (100 - this.할인률) / 100;
  }
}

console.log(앞다리1.getPrice()); //가격
```

```
캡슐화를 하여 변수의 사용을 줄여주고, 결과값을 쉽게 얻을수있다.
```

## inheritance

상품을 진열하다보니 상품을 분류할수 있는 코드가 있으면 빠르게 작업을 할수 있을것 같아서 분류코드 (category) 를 만들기로 했다.
```js
class 정육 {
  constructor(){
    key = "private";
    category = "정육";
    상품분류 = "고기";
  }
}

class 앞다리살 extends 정육 {
 constructor(가격, 무게, 할인률){
  super();
  this.가격 = this.가격;
  this.무게 = this.무게;
  this.할인률 = this.할인률;
 }
 getPrice : function() {
    return this.가격 * this.무게 * (100 - this.할인률) / 100;
  }
}

var 앞다리살1 = new 앞다리살(1000, 850, 30);
console.log(앞다리살1.getPrice());
```

```
앞다리살 은 '정육' 을 상속받아 중복되는코드 ( category, 상품분류 ... ) 을 쓰지않아도 된다.
```

## Abstraction

```js
//이전에는 앞다리살1의 가격을 알기위해서는

console.log(getPrice(앞다리살1가격, 앞다리살1무게, 앞다리살1할인률)) 
// 을 통해서 알아야 했지만 캡슐화을 하니
console.log(앞다리살1.getPrice())
//를 통해서  알수잇어 코드가 추상적으로 알아보기 쉽다.
```
